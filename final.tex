\documentclass[report]{jlreq}

\usepackage{listings}

\author{2013553 中野将生}
\date{\today}
\title{S8 最終レポート}

\lstset {
  language = caml
}

\begin{document}
  \maketitle
  \chapter{成果物の概要}
    本実験で実装した処理系は\texttt{./code/bin/main.ml}と\texttt{./compiler/main.ml}の2種類である。
    前者の処理系は課題6-2までの機能を実装した木構造に対するインタプリタ、
    CAM、ZAMへのコンパイルと実行が可能である。第一引数に\texttt{tree}、\texttt{cam}、\texttt{zam}を指定し、
    第２引数にファイルを指定する事で実行できる。
    後者の処理系はパターンマッチ、高階型を含む多相型推論と、簡単なサブセット言語のコンパイル機能がある。
    簡単のため以降前者をコンパイラ1、後者をコンパイラ2と呼ぶ。

    コンパイラ1は\texttt{code}ディレクトリで\texttt{dune build}を行うと\texttt{code/\_build/default/bin/main.exe}
    に実行可能ファイルが生成される。コンパイラ2は\texttt{./compiler}ディレクトリで\texttt{make}を実行すれば
    単体テストが実行され\texttt{compiler}という名前でコンパイラがビルドされる。
  \chapter{実行例}
    \subsection{マッカーシーの91関数}
      図\ref{maccarthy-91-ml}にソースコードを、図\ref{maccarthy-91-result}に実行結果を示す。
      かなり軽い処理で実行時間の計測はあまり意味が無かった。
      \lstinputlisting[caption = コンパイラ1によるMcCarthy91の実行結果, label=maccarthy-91-result]{./figures/maccarchy91.sh}
      \lstinputlisting[caption = maccarthy91.ml, label=maccarthy-91-ml]{./code/example/maccarthy91.ml}
    \subsection{フィボナッチ数列}
      図\ref{fib-exec}はソースコード\ref{code-fib-ml}をコンパイラ1を用いて実行した際の結果である。
      \texttt{tree}が最も遅いのは自然な結果だが、\texttt{ZAM}も\texttt{tree}と殆ど同じ速度となっている。
      命令セットｔが複雑なため、フィボナッチ数列のような単純なプログラムではあまり速度が出ない可能性、
      ランタイムが効率の良い実装になっていない可能性が考えられる。
      特にZAMでは\texttt{Grab}命令を追加した事で複数引数を効率よく扱えるようにはなっているが、
      フィボナッチ数列だと引数は一つしか取らないためかえってオーバーヘッドが生じている可能性がある。
      \lstinputlisting[caption = fib.ml, label = code-fib-ml]{./code/example/fib.ml}
      \lstinputlisting[caption = コンパイラ1によるfibの実行結果, label = fib-exec, language=bash]{./figures/bench.sh}

      図\ref{compiled-fib-result}はソースコード\ref{code-fib-ml-stmt}をコンパイラ2でコンパイルした後
      実行した際の結果である。
      コンパイル時間と実行時間を別々に計測している。
      コンパイル時間を含めてもインタプリタ実装に比べ高速な実行が出来ているが、
      CAMの実行時間はバイナリの$1.8$倍に過ぎないのであまり効率の良いコードを生成しているとは言えない。
      \lstinputlisting[caption = コンパイラ2によるfibの実行結果, label=compiled-fib-result]{./figures/bin_bench.sh}
      \lstinputlisting[caption = fib\_stmt.ml, label=code-fib-ml-stmt]{./compiler/example/fib.ml}

      参考までに\texttt{ocaml}と\texttt{ocamlopt}によって生成されたバイナリの実行結果を示す。
      ソースコードはコンパイラ2のものと同一である。
      \lstinputlisting[caption = OCamlによるfibの実行結果]{./figures/fib_ocaml.sh}
    \subsection{実行速度のまとめ}
      \begin{table}[t]
        \centering
        \caption{実行速度の比較表}
        \begin{tabular}{l|lll}
        implementation & fib 35         & tarai 12 6 0                 & ack 3 11                      \\ \hline
        ocamlopt       & $64.86       $ & $ 30.01        $ & $ 69.74        $ \\
        ocaml          & $387.18      $ & $ 161.78       $ & $ 373.41       $ \\
        compiler2      & $932.89      $ & $ \mathrm{N/A} $ & $ 873.88       $ \\
        compiler1 tree & $2.71 * 10^3 $ & $ 2.11 * 10^3  $ & $ 12.47 * 10^3 $ \\
        compiler1 cam  & $1.83 * 10^3 $ & $ \mathrm{N/A} $ & $ \mathrm{N/A} $ \\
        compiler1 zam  & $2.70 * 10^3 $ & $ 1937.38      $ & $ 16.03 * 10^3 $
        \end{tabular}
      \end{table}
  \chapter{実装したコンパイラの解説及び言語処理系の考察}
  \chapter{本実験全体の考察及び感想}
  \chapter{ソースコード}
\end{document}
