@import: ./coins.satyh/coins-report
@require: enumitem/enumitem

document(|
  author = {中野 将生};
  department = {情報科};
  faculty = {情報};
  id = 2013553;
  title = {関数プログラミング 5-1};
  en = false;
|) '<
  +section ?* ?* ?:((5,1)) {静的束縛と動的束縛} <
    +subsection{静的束縛} <
      +listing ?:(Enumitem.dot-arabic) {
        * プログラム全体を、空の束縛のもとで実行する
        * `x=10`という束縛を有効にして、2行目以下のプログラムをこの束縛のスコープとする
        * `f = fun y -> x + y`という束縛を有効にして、3行目以下のプログラムをこのスコープとする
        * `f x`を実行する。この時の`x`は`10`なので`f x`は`(fun y -> x + y) 10`となり、`y = 20`に束縛される。
        * `x=20`という束縛を有効にして、5行目以下のプログラムをこの束縛のスコープとする
        * `f (x * y)`を実行する。つまり`(fun f y -> x + y) 400`を実行する。このときの`x`は`20`なので`420`
      }
    >
    +subsection{動的束縛} <
      +listing ?:(Enumitem.dot-arabic) {
        * プログラム全体を、空の束縛のもとで実行する
        * `x=10`という束縛を有効にして、2行目以下のプログラムをこの束縛のスコープとする
        * `f = fun y -> x + y`という束縛を有効にして、3行目以下のプログラムをこのスコープとする
        * `f x`を実行する。この時の`x`は`10`なので`f x`は`(fun y -> x + y) 10`となり、`f`のスコープでの`x`は`10`なので`y = 20`に束縛される。
        * `x=20`という束縛を有効にして、5行目以下のプログラムをこの束縛のスコープとする
        * `f (x * y)`を実行する。つまり`(fun f y -> x + y) 200`を実行する。このとき`f`のスコープでの`x`は`10`なので`410`
      }
    >
  >
  +section {関数の処理とクロージャ} <
    +subsection{eval4の確認} <
      +code(```
        # Kadai5.Top.eval_string "let x = 1 in let f = fun y -> x + y in let x = 2 in f (x + 3)";;
        - : Kadai5.Ast.value_t = Kadai5.Ast.IntVal 6
      ```);
    >
    +subsection{動的束縛への変更}<
      +code(```
        # Kadai5.Top.eval_string "let x = 1 in let f = fun y -> x + y in let x = 2 in f (x + 3)";;
        - : Kadai5.Ast.value_t = Kadai5.Ast.IntVal 7
      ```);
      +p{
        fが適用される時点でfが定義された時点には無かった`x = 2`を用いて計算が行われているので動的束縛と言える。
      }
    >
    +subsection ?:(`fixed-point`) ?* {階乗を求める関数が定義出来るかどうか} <
      +p{
        型無しなので不動点コンビネータを定義することが出来る。評価戦略は`call-by-value`で実装しているのでZコンビネータを用い、
        以下のように計算される。式が長いためテストコードから引用する。
      }
      +code(```
      let test_z _ = 
          let fix = parse_string "fun f -> (fun x -> f (fun y -> x x y)) (fun x -> f (fun y -> x x y))" in
          let fact = parse_string "fun f -> fun n -> if n = 1 then 1 else n * (f (n-1))" in
          let exp = App (App (fix, fact), IntLit 5) in
          assert_equal (eval (emptyenv ()) exp) (IntVal 120)
      ```);
    >
    +subsection{評価順序の確認} <
      +p{
        右の引数を評価してから左の引数を評価するようになっている。
        ここでは見やすさのため`print_endline`を使った。
      }
      +code(```
        # (print_endline "1"; 10) + (print_endline "2"; 20);;
        2
        1
        - : int = 30
        # (print_endline "1"; (fun x -> x))  (print_endline "2"; 20);;
        2
        1
        - : int = 20
      ```);
    >
    +subsection{本実験の処理系での評価順序の確認} <
      +p{
        仕様を拡張し、デバッグ出力を行う`debug_print`と`;`演算子を追加して実験を行った。
        `ocaml`の実装とは逆となっていることが分かる。
      }
      +code(```
        # eval_string "(debug_print 1; 10) + (debug_print 2; 20)";;
        (K5ast.IntVal 1)
        (K5ast.IntVal 2)
        - : S8.K5ast.value_t = S8.K5ast.IntVal 30
        # eval_string "(debug_print 1; (fun x -> x)) (debug_print 2; 20)";;
        (K5ast.IntVal 1)
        (K5ast.IntVal 2)
        - : S8.K5ast.value_t = S8.K5ast.IntVal 20
      ```);
    >
    +subsection{修正} <
      +p{
        添付のソースコードでは修正が行われている。
      }
    >
  >
  +section{再帰関数の処理}<
    +subsection{テストプログラム} <
      +code(```
      # eval_string "let rec f x = x in 0";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 0
      # eval_string "let rec f x = x in f 0";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 0
      # eval_string "let rec f x = if x = 0 then 1 else 2 + f (x + (- 1)) in f 0";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 1
      # eval_string "let rec f x = if x = 0 then 1 else x * f (x + (- 1)) in f 3";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 6
      # eval_string "let rec f x = if x = 0 then 1 else x * f (x + (- 1)) in f 5";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 120
      ```);
    >
    +subsection{フィボナッチ関数} <
      +code(```
      # eval_string "let rec fib n = if n = 0 || n = 1 then 1 else (fib (n-1)) + (fib (n-2)) in fib 4";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 5
      # eval_string "let rec fib n = if n = 0 || n = 1 then 1 else (fib (n-1)) + (fib (n-2)) in fib 5";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 8
      # eval_string "let rec fib n = if n = 0 || n = 1 then 1 else (fib (n-1)) + (fib (n-2)) in fib 6";;
      - : S8.K5ast.value_t = S8.K5ast.IntVal 13
      ```);
    >
    +subsection{環境の拡張の抑制} <
      +p{
        実引数は毎回変わりうるが再帰する関数自身は変わらない。
        `eval`の引数に自身を追加した環境を持たせ、
        関数にユニークなIDを振ってそれを見る事で2回目以降の再帰において自身を環境へ登録する事を省ける。
        ユニークなIDはパース時にグローバルなカウンタをインクリメントして決めれば良い。
      }
    >
    +subsection{他の実装法} <
      +p{
        第2の方法を実装した。なお、第三の方法は\ref-sec(`fixed-point`);が本節をかねている。
      }
    >
  >
>
