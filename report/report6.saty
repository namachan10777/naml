@import: ./coins.satyh/coins-report
@require: enumitem/enumitem

document(|
  author = {中野 将生};
  department = {情報科};
  faculty = {情報};
  id = 2013553;
  title = {関数プログラミング 5-1};
  en = false;
|) '<
  +section ?* ?* ?:((5,1)) {静的束縛と動的束縛} <
    +subsection{静的束縛} <
      +listing ?:(Enumitem.dot-arabic) {
        * プログラム全体を、空の束縛のもとで実行する
        * `x=10`という束縛を有効にして、2行目以下のプログラムをこの束縛のスコープとする
        * `f = fun y -> x + y`という束縛を有効にして、3行目以下のプログラムをこのスコープとする
        * `f x`を実行する。この時の`x`は`10`なので`f x`は`(fun y -> x + y) 10`となり、`y = 20`に束縛される。
        * `x=20`という束縛を有効にして、5行目以下のプログラムをこの束縛のスコープとする
        * `f (x * y)`を実行する。つまり`(fun f y -> x + y) 400`を実行する。このときの`x`は`20`なので`420`
      }
    >
    +subsection{動的束縛} <
      +listing ?:(Enumitem.dot-arabic) {
        * プログラム全体を、空の束縛のもとで実行する
        * `x=10`という束縛を有効にして、2行目以下のプログラムをこの束縛のスコープとする
        * `f = fun y -> x + y`という束縛を有効にして、3行目以下のプログラムをこのスコープとする
        * `f x`を実行する。この時の`x`は`10`なので`f x`は`(fun y -> x + y) 10`となり、`f`のスコープでの`x`は`10`なので`y = 20`に束縛される。
        * `x=20`という束縛を有効にして、5行目以下のプログラムをこの束縛のスコープとする
        * `f (x * y)`を実行する。つまり`(fun f y -> x + y) 200`を実行する。このとき`f`のスコープでの`x`は`10`なので`410`
      }
    >
  >
  +section {関数の処理とクロージャ} <
    +subsection{eval4の確認} <
      +code(```
        # Kadai5.Top.eval_string "let x = 1 in let f = fun y -> x + y in let x = 2 in f (x + 3)";;
        - : Kadai5.Ast.value_t = Kadai5.Ast.IntVal 6
      ```);
    >
    +subsection{動的束縛への変更}<
      +code(```
        # Kadai5.Top.eval_string "let x = 1 in let f = fun y -> x + y in let x = 2 in f (x + 3)";;
        - : Kadai5.Ast.value_t = Kadai5.Ast.IntVal 7
      ```);
      +p{
        fが適用される時点でfが定義された時点には無かった`x = 2`を用いて計算が行われているので動的束縛と言える。
      }
    >
    +subsection{階乗を求める関数が定義出来るかどうか} <
      +p{

      }
    >
  >
>
